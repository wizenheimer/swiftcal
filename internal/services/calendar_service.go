// internal/services/calendar_service.go
package services

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/wizenheimer/swiftcal/internal/config"
	"github.com/wizenheimer/swiftcal/internal/models"
	"github.com/wizenheimer/swiftcal/pkg/logger"

	"github.com/google/uuid"
	"go.uber.org/zap"
	"google.golang.org/api/calendar/v3"
	"google.golang.org/api/option"
)

type CalendarService struct {
	config      *config.Config
	authService *AuthService
}

func NewCalendarService(cfg *config.Config, authService *AuthService) *CalendarService {
	return &CalendarService{
		config:      cfg,
		authService: authService,
	}
}

func (s *CalendarService) AddEvent(ctx context.Context, userID uuid.UUID, event *models.Event) (*models.GoogleCalendarEvent, error) {
	// Get OAuth client for the user
	client, err := s.authService.GetOAuthClient(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get OAuth client: %w", err)
	}

	// Create calendar service
	calendarService, err := calendar.NewService(ctx, option.WithHTTPClient(client))
	if err != nil {
		return nil, fmt.Errorf("failed to create calendar service: %w", err)
	}

	// Get primary calendar
	calendarList, err := calendarService.CalendarList.List().Do()
	if err != nil {
		return nil, fmt.Errorf("failed to get calendar list: %w", err)
	}

	var primaryCalendar *calendar.CalendarListEntry
	for _, cal := range calendarList.Items {
		if cal.Primary {
			primaryCalendar = cal
			break
		}
	}

	if primaryCalendar == nil {
		return nil, fmt.Errorf("primary calendar not found")
	}

	// Convert event to Google Calendar format
	googleEvent, err := s.convertToGoogleEvent(event, primaryCalendar.TimeZone)
	if err != nil {
		return nil, fmt.Errorf("failed to convert event: %w", err)
	}

	// Add description footer
	if googleEvent.Description != "" {
		googleEvent.Description += "\n\n"
	}
	googleEvent.Description += "This event was generated by AI with swiftcal.\nDon't waste time creating events, just forward them to " + s.config.MainEmailAddress + "."

	// Create the event
	createdEvent, err := calendarService.Events.Insert(primaryCalendar.Id, googleEvent).
		ConferenceDataVersion(1).
		SendNotifications(true).
		SendUpdates("all").
		Do()

	if err != nil {
		return nil, fmt.Errorf("failed to create calendar event: %w", err)
	}

	// Convert back to our model
	result := &models.GoogleCalendarEvent{
		ID:          createdEvent.Id,
		Summary:     createdEvent.Summary,
		Description: createdEvent.Description,
		Location:    createdEvent.Location,
		HTMLLink:    createdEvent.HtmlLink,
	}

	if createdEvent.Start != nil {
		if createdEvent.Start.DateTime != "" {
			if startTime, err := time.Parse(time.RFC3339, createdEvent.Start.DateTime); err == nil {
				result.StartTime = startTime
				result.TimeZone = createdEvent.Start.TimeZone
			}
		}
	}

	if createdEvent.End != nil {
		if createdEvent.End.DateTime != "" {
			if endTime, err := time.Parse(time.RFC3339, createdEvent.End.DateTime); err == nil {
				result.EndTime = endTime
			}
		}
	}

	// Convert attendees
	for _, attendee := range createdEvent.Attendees {
		result.Attendees = append(result.Attendees, models.GoogleCalendarAttendee{
			Email:       attendee.Email,
			DisplayName: attendee.DisplayName,
			Organizer:   attendee.Organizer,
		})
	}

	logger.GetLogger().Info("Calendar event created",
		zap.String("user_id", userID.String()),
		zap.String("event_id", result.ID),
		zap.String("summary", result.Summary))

	return result, nil
}

func (s *CalendarService) convertToGoogleEvent(event *models.Event, defaultTimezone string) (*calendar.Event, error) {
	// Parse date and times
	timezone := defaultTimezone
	if event.TimeZone != nil && *event.TimeZone != "" {
		timezone = *event.TimeZone
	}

	// Parse start time
	startTimeStr := fmt.Sprintf("%s %s", event.Date, event.StartTime)
	startTime, err := time.Parse("2 January 2006 15:04", startTimeStr)
	if err != nil {
		return nil, fmt.Errorf("failed to parse start time: %w", err)
	}

	// Load timezone
	loc, err := time.LoadLocation(timezone)
	if err != nil {
		logger.GetLogger().Warn("Invalid timezone, using default",
			zap.String("timezone", timezone),
			zap.Error(err))
		loc, _ = time.LoadLocation(defaultTimezone)
	}

	startTime = startTime.In(loc)

	// Parse end time
	var endTime time.Time
	if event.EndTime != nil && *event.EndTime != "" {
		endTimeStr := fmt.Sprintf("%s %s", event.Date, *event.EndTime)
		endTime, err = time.Parse("2 January 2006 15:04", endTimeStr)
		if err != nil {
			logger.GetLogger().Warn("Failed to parse end time, using default duration",
				zap.Error(err))
			endTime = startTime.Add(30 * time.Minute)
		} else {
			endTime = endTime.In(loc)
			// Validate end time is after start time
			if !endTime.After(startTime) {
				logger.GetLogger().Warn("End time is not after start time, using default duration")
				endTime = startTime.Add(30 * time.Minute)
			}
		}
	} else {
		// Default 30 minutes
		endTime = startTime.Add(30 * time.Minute)
	}

	// Create Google Calendar event
	googleEvent := &calendar.Event{
		Summary: event.Summary,
		Start: &calendar.EventDateTime{
			DateTime: startTime.Format(time.RFC3339),
			TimeZone: timezone,
		},
		End: &calendar.EventDateTime{
			DateTime: endTime.Format(time.RFC3339),
			TimeZone: timezone,
		},
		Status:                  "confirmed",
		GuestsCanInviteOthers:   &[]bool{true}[0],
		GuestsCanModify:         true,
		GuestsCanSeeOtherGuests: &[]bool{true}[0],
	}

	if event.Description != nil {
		googleEvent.Description = *event.Description
	}

	if event.Location != nil {
		googleEvent.Location = *event.Location
	}

	// Add attendees (filter out invalid emails)
	var validAttendees []*calendar.EventAttendee
	for _, email := range event.Attendees {
		if s.isValidEmail(email) {
			validAttendees = append(validAttendees, &calendar.EventAttendee{
				Email: email,
			})
		} else {
			logger.GetLogger().Warn("Skipping invalid email address",
				zap.String("email", email))
		}
	}
	googleEvent.Attendees = validAttendees

	return googleEvent, nil
}

func (s *CalendarService) isValidEmail(email string) bool {
	// Basic email validation
	return strings.Contains(email, "@") &&
		strings.Contains(email, ".") &&
		len(email) > 5 &&
		!strings.HasPrefix(email, "@") &&
		!strings.HasSuffix(email, "@") &&
		!strings.Contains(email, "..") &&
		!strings.Contains(email, " ")
}

func (s *CalendarService) InviteAdditionalAttendees(ctx context.Context, userID uuid.UUID, eventID, calendarID string, attendees []string) error {
	// Get OAuth client for the user
	client, err := s.authService.GetOAuthClient(ctx, userID)
	if err != nil {
		return fmt.Errorf("failed to get OAuth client: %w", err)
	}

	// Create calendar service
	calendarService, err := calendar.NewService(ctx, option.WithHTTPClient(client))
	if err != nil {
		return fmt.Errorf("failed to create calendar service: %w", err)
	}

	// Get the existing event
	event, err := calendarService.Events.Get(calendarID, eventID).Do()
	if err != nil {
		return fmt.Errorf("failed to get event: %w", err)
	}

	// Add new attendees
	for _, email := range attendees {
		if s.isValidEmail(email) {
			event.Attendees = append(event.Attendees, &calendar.EventAttendee{
				Email: email,
			})
		}
	}

	// Update the event
	_, err = calendarService.Events.Update(calendarID, eventID, event).
		SendNotifications(true).
		SendUpdates("all").
		ConferenceDataVersion(1).
		Do()

	if err != nil {
		return fmt.Errorf("failed to update event: %w", err)
	}

	logger.GetLogger().Info("Additional attendees invited",
		zap.String("user_id", userID.String()),
		zap.String("event_id", eventID),
		zap.Strings("attendees", attendees))

	return nil
}

func (s *CalendarService) GetUserCalendars(ctx context.Context, userID uuid.UUID) ([]*calendar.CalendarListEntry, error) {
	// Get OAuth client for the user
	client, err := s.authService.GetOAuthClient(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get OAuth client: %w", err)
	}

	// Create calendar service
	calendarService, err := calendar.NewService(ctx, option.WithHTTPClient(client))
	if err != nil {
		return nil, fmt.Errorf("failed to create calendar service: %w", err)
	}

	// Get calendar list
	calendarList, err := calendarService.CalendarList.List().Do()
	if err != nil {
		return nil, fmt.Errorf("failed to get calendar list: %w", err)
	}

	return calendarList.Items, nil
}
